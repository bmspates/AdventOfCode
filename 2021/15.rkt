#lang racket
(require "input.rkt" "utils.rkt" "point.rkt")
(require graph  dyoo-while-loop)
(provide main)

(define (add-modulo a b m)
  (modulo (+ a b) m))

(define (parse-input part ls)
  (define ls-y (length ls))
  (define ls-x (length (list-ref ls 0)))
  (define r (* (if (equal? part 'p1) 1 5) ls-x))
  (define c (* (if (equal? part 'p1) 1 5) ls-y))
  (define weights
    (let ((h (make-hash))
          (b (box '())))
      (for ((row c))
        (for ((col r))
          (hash-set! h (point col row)
                     (if (equal? part 'p1) (list-ref2 ls row col)
                         (let ((tile-x (quotient col ls-x))
                               (tile-y (quotient row ls-y)))
                           (match (+ tile-x tile-y (list-ref2 ls (modulo row ls-x) (modulo col ls-y)))
                             [x #:when (> x 9) (- x 9)]
                             [x x]))))))
      h))
  (define (make-paths)
    (let ((b (box '())))
      (for/list ((row (make-points r c)))
        (for/list ((p row))
          (for/list ((n (adj-points p r c)))
            (set-box! b (cons (list (hash-ref weights n) p n)
                              (unbox b))))))
      (unbox b)))
  (weighted-graph/directed (make-paths)))

(define (main)
  (let ((g (parse-input 'p2 (map (Î» (x) (string->int-list "" x))
                                 (read-lines "inputs/day15.txt")))))
    (let-values ([(cost pred) (dijkstra g (point 0 0))])
      (hash-ref cost (bottom-right (get-vertices g))))))
